import * as vscode from 'vscode';
import * as _ from 'lodash';

const LINE_LENGTH = 80;

function commentCarWash (line:any, commentSeparator:string, startChar: number): string {
    const newLines = [];
    const words = _.words(line.codeRes);
    while (words.length > 0) {
        let line = '';
        while (line.length < LINE_LENGTH && words.length > 0) {
            line += words.shift() + ' ';
        }
        newLines.push(line);
    }

    return newLines.join('\n')
    .replace(commentSeparator, '')
    .replaceAll("\'", "\\'")
    .split('\n')
    .map((ln:string , idx:number) => {
        if (idx === 0) {
            return ln;
        } 
        return `${' '.repeat(startChar)}${ln}`;
    })
    .join('\n')
    .trim();
}

export function commentGenerator(line:any, startChar: number, language:string): string {
    const commentTypes:any = {
        'typescript': { start: '/*', end: '*/' },
        'tsx': { start: '/*', end: '*/' },
        'javascript': { start: '/*', end: '*/' },
        'html': { start: '<!--', end: '-->' },
        'css': { start: '/*', end: '*/' },
        'java': { start: '/*', end: '*/' },
        'c': { start: '/*', end: '*/' },
        'cpp': { start: '/*', end: '*/' },
        'csharp': { start: '/*', end: '*/' },
        'python': { start: "'''", end: "'''" },
        'php': { start: '/*', end: '*/' },
        'ruby': { start: "'''", end: "'''" },
    };

    const commentSeparator = commentTypes[language];

    return `${' '.repeat(startChar)}${commentSeparator.start}\n${' '.repeat(startChar)}${commentCarWash(line, commentSeparator.end, startChar)}\n${' '.repeat(startChar)}- generated by stenography autopilot [ 🚗👩‍✈️ ] \n${' '.repeat(startChar)}${commentSeparator.end}`;
}

export function comment(editor: vscode.TextEditor | undefined, language: string, stenographyObject: any) {
    let ZERO_COLUMN = vscode.workspace.getConfiguration().get('stenography.autopilotSettings.zeroCol');

    
    
    if (!editor) {  
        vscode.window.showErrorMessage('Commit Comment :: No active editor');
        return;
    }

    if (!stenographyObject) {
        vscode.window.showErrorMessage('Commit Comment :: No stenography object');
        return;
    }

    if (!language) {
        vscode.window.showErrorMessage('Commit Comment :: No language');
        return;
    }

    const linesA: any[] = [];

    const columnPlacement = ZERO_COLUMN ? 1 : stenographyObject.startPosition.column - 1;

    editor?.edit(edit => {
        const lineAboveNewLine = new vscode.Position(
            stenographyObject.startPosition.row - 1,
            columnPlacement
        );
        linesA.push({ line: lineAboveNewLine, codeRes: stenographyObject.stenographyResult.pm });

        linesA.forEach((line:any) => {
            edit.insert(new vscode.Position(line.line.line, 0), '\n');
        });

    }).then(() => {
        editor?.edit(edit => {
            linesA.forEach((line:any, idx:number) => {
                const startChar = line.line.character;
                edit.insert(
                    new vscode.Position(line.line.line + idx, line.line.character), 
                    commentGenerator(line, startChar, language));
            });
        });
    });
}