/* eslint-disable @typescript-eslint/naming-convention */
// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import fetch from 'node-fetch';
import DEBUG_KEY from './env';

let STENOGRAPHY_API_KEY: string | null = DEBUG_KEY() || null;

async function showInputBox() {
	const result: string | undefined = await vscode.window.showInputBox({
		value: '',
		placeHolder: 'Input your Stenography API Key',
	});

	try {
		if (result) {
			setStenographyAPIKey(result);
			vscode.window.showInformationMessage("Key added to stenography session!");
		} else {
			throw new Error('result is undefined');
		}
	} catch (error) {
		console.error("Invalid key");
		return "Invalid Key";
	}
}

const setStenographyAPIKey = (key: string) => {
	STENOGRAPHY_API_KEY = key;
};

interface StenographyResponse {
	pm: string,
	code: string,
	metadata: any
}

interface AutopilotResponse {
	// eslint-disable-next-line @typescript-eslint/naming-convention
	invocation_counter: number,
	// eslint-disable-next-line @typescript-eslint/naming-convention
	code_blocks: [CodeBlock]
}

interface CodeBlock {
	stenographyResult: StenographyResponse,
	startPosition: any,
	endPosition: any
}

const fetchStenographyAutopilot = async (code: string, language: string, dryRun: boolean = true): Promise<AutopilotResponse> => {
	console.log(code)


	let fetchUrl = 'https://stenography-worker.stenography.workers.dev/autopilot';

	let options = {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ 
			"code": code, 
			"api_key": STENOGRAPHY_API_KEY, 
			"dry_run": dryRun, 
			"index_by_one": true, 
			"add_import": false, 
			"language": language, 
			"stenography_options": { 
				"audience": "pm",
				"stackoverflow": false,
				"populate": false
			} 
		})
	};

	try {
		console.log(fetchUrl);
		const resp = await fetch(fetchUrl, options);
		const json: any = await resp.json();
	
		return json;
	} catch (err) {
		console.error(err);
		throw err;
	}
};

const logic = async (editor: vscode.TextEditor | undefined) => {
	// The code you place here will be executed every time your command is executed
	let code: string | undefined = editor?.document.getText();
	const filename: string[] | undefined = editor?.document.fileName.split('.');
	const fileType: string | undefined = filename?.slice(-1)[0];

	vscode.window.withProgress({
		location: vscode.ProgressLocation.Window,
		cancellable: false,
		title: 'Fetching from Stenography Autopilot'
	}, async (progress) => {
		progress.report({ increment: 0 });
		if (code) {
			if (editor) {

				const res = await fetchStenographyAutopilot(code, 'typescript', true);

				console.log(res);

				const linesA:any = [];

				for (let i = 0; i < res.code_blocks.length; i++) {
					const codeBlock = res.code_blocks[i];

					const lineAboveNewLine = new vscode.Position(
						codeBlock.startPosition.row - 2,
						codeBlock.startPosition.column
					);
					
					linesA.push({ line: lineAboveNewLine, codeRes: codeBlock.stenographyResult.pm });
					
				}

				editor?.edit(edit => {
					linesA.forEach((line:any) => {
						edit.insert(line.line, '/*\n' + line.codeRes + '*/');
					});
				});

				// editor?.edit(edit => {

				// 	if (fileType === 'py') {
				// 		edit.insert(new vscode.Position(lineAbove, startChar), `${' '.repeat(startChar)}'''\n${' '.repeat(startChar)}${descriptionResult.dev.trimLeft()}\n${' '.repeat(startChar)}- generated by stenography ðŸ¤–\n${' '.repeat(startChar)}'''`);
				// 	}
				// 	else {
				// 		edit.insert(new vscode.Position(lineAbove, startChar), `${' '.repeat(startChar)}/*\n${' '.repeat(startChar)}${descriptionResult.dev.trimLeft()}\n${' '.repeat(startChar)}- generated by stenography ðŸ¤–\n${' '.repeat(startChar)}*/`);
				// 	}
				// });
			}

			progress.report({ increment: 100 });
		} else {
			console.error('error fetching code block');
		}
	});
};


// this method is called when your extension is activated
// your extension is activated the very first time the command is executed
export function activate(context: vscode.ExtensionContext) {

	// Use the console to output diagnostic information (console.log) and errors (console.error)
	// This line of code will only be executed once when your extension is activated
	console.log('Congratulations, your extension "stenography" is now active!');

	let setKeyDisposable = vscode.commands.registerCommand('stenography.setKey', async () => {
		await showInputBox();
	});

	// The command has been defined in the package.json file
	// Now provide the implementation of the command with registerCommand
	// The commandId parameter must match the command field in package.json
	let disposable = vscode.commands.registerCommand('stenography.helloWorld', async () => {
		const editor = vscode.window.activeTextEditor;
		await logic(editor);
	});

	context.subscriptions.push(setKeyDisposable);
	context.subscriptions.push(disposable);
}

// this method is called when your extension is deactivated
export function deactivate() { }
