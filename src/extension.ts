/* eslint-disable @typescript-eslint/naming-convention */
// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import fetch from 'node-fetch';
import DEBUG_KEY from './env';

let STENOGRAPHY_API_KEY: string | null = DEBUG_KEY() || null;

async function showInputBox() {
	const result: string | undefined = await vscode.window.showInputBox({
		value: '',
		placeHolder: 'Input your Stenography API Key',
	});

	try {
		if (result) {
			setStenographyAPIKey(result);
			vscode.window.showInformationMessage("Key added to stenography session!");
		} else {
			throw new Error('result is undefined');
		}
	} catch (error) {
		console.error("Invalid key");
		return "Invalid Key";
	}
}

const setStenographyAPIKey = (key: string) => {
	STENOGRAPHY_API_KEY = key;
};

interface StenographyResponse {
	pm: string,
	code: string,
	metadata: any
}

interface AutopilotResponse {
	// eslint-disable-next-line @typescript-eslint/naming-convention
	invocation_counter: number,
	// eslint-disable-next-line @typescript-eslint/naming-convention
	code_blocks?: [CodeBlock]
	error?: any
}

interface CodeBlock {
	stenographyResult: StenographyResponse,
	startPosition: any,
	endPosition: any
}

const fetchStenographyAutopilot = async (code: string, language: string, dryRun: boolean = true): Promise<AutopilotResponse> => {

	let fetchUrl = 'https://stenography-worker.stenography.workers.dev/autopilot';

	let options = {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ 
			"code": code, 
			"api_key": STENOGRAPHY_API_KEY, 
			"dry_run": dryRun, 
			"index_by_one": true, 
			"add_import": false, 
			"language": language, 
			"stenography_options": { 
				"audience": "pm",
				"stackoverflow": false,
				"populate": false
			} 
		})
	};

	try {
		console.log(fetchUrl);
		const resp = await fetch(fetchUrl, options);
		console.log(resp);
		const json: any = await resp.json();
		if (typeof json === 'string') {
			throw new Error(json);
		}
		return json;
	} catch (err: any) {
		console.error(err);
		return { error: err, invocation_counter: -1 };
	}
};

const FILETYPES:any = {
	"ts": "typescript",
	"js": "javascript",
	"py": "python",
};

const logic = async (editor: vscode.TextEditor | undefined, isDryRun = true) => {
	// The code you place here will be executed every time your command is executed
	let code: string | undefined = editor?.document.getText();
	const filename: string[] | undefined = editor?.document.fileName.split('.');
	const fileType: string | undefined = filename?.slice(-1)[0];

	let language:string;
	
	if (fileType) {
		language = FILETYPES[fileType];
	} else {
		vscode.window.showErrorMessage("Language not yet supported");
		return;
	}

	vscode.window.withProgress({
		location: vscode.ProgressLocation.Window,
		cancellable: false,
		title: 'Fetching from Stenography Autopilot'
	}, async (progress) => {
		progress.report({ increment: 0 });
		if (code) {
			if (editor) {

				const res = await fetchStenographyAutopilot(code, language, isDryRun);
				console.log(res);
				if (res.error) {
					vscode.window.showErrorMessage(res.error.message);
					return;
				}

				const linesA:any = [];

				for (let i = 0; i < res.code_blocks!.length; i++) {
					const codeBlock = res.code_blocks![i];


					const lineAboveNewLine = new vscode.Position(
						codeBlock.startPosition.row - 1,
						codeBlock.startPosition.column - 1
					);
					
					if(isDryRun) {
						linesA.push({ line: lineAboveNewLine, codeRes: `dry run -- stenography will explain this code block!` });
					} else {
						linesA.push({ line: lineAboveNewLine, codeRes: codeBlock.stenographyResult.pm });
					}		
				}

				switch (language) {
					case 'typescript':
					case 'javascript':
						editor?.edit(edit => {
							linesA.forEach((line:any) => {
								edit.insert(new vscode.Position(line.line.line, 0), '\n');
							});
						}).then(() => {
							editor?.edit(edit => {
								linesA.forEach((line:any, idx:number) => {
									edit.insert(new vscode.Position(line.line.line + idx, line.line.character), `${' '.repeat(line.line.character)}/*\n${' '.repeat(line.line.character)}${line.codeRes.replace('*/', '').trim()}\n${' '.repeat(line.line.character)}- generated by stenography autopilot [ 🚗👩‍✈️ ] \n${' '.repeat(line.line.character)}*/`);
								});
							});
						});
						break;
					case 'python':
						editor?.edit(edit => {
							linesA.forEach((line:any) => {
								edit.insert(new vscode.Position(line.line.line, 0), '\n');
							});
						}).then(() => {
							editor?.edit(edit => {
								linesA.forEach((line:any, idx:number) => {
									edit.insert(new vscode.Position(line.line.line + idx, line.line.character), `${' '.repeat(line.line.character)}'''\n${' '.repeat(line.line.character)}${line.codeRes.replace('\'\'\'', '').trim()}\n${' '.repeat(line.line.character)}- generated by stenography autopilot [ 🚗👩‍✈️ ] \n${' '.repeat(line.line.character)}'''`);
								});
							});
						});
						break;
					default:
						vscode.window.showErrorMessage("Language not yet supported");
						break;
					}

			}

			progress.report({ increment: 100 });
		} else {
			console.error('error fetching code block');
		}
	});
};


export function activate(context: vscode.ExtensionContext) {
	console.log('Congratulations, your extension "stenography" is now active!');

	let setKeyDisposable = vscode.commands.registerCommand('stenography.setKey', async () => {
		await showInputBox();
	});

	let disposable = vscode.commands.registerCommand('stenography.autopilot', async () => {
		const editor = vscode.window.activeTextEditor;
		await logic(editor, false);
	});

	let disposableDryRun = vscode.commands.registerCommand('stenography.autopilot-dryrun', async () => {
		const editor = vscode.window.activeTextEditor;
		await logic(editor, true);
	});

	context.subscriptions.push(disposableDryRun);
	context.subscriptions.push(setKeyDisposable);
	context.subscriptions.push(disposable);
}

// this method is called when your extension is deactivated
export function deactivate() { }
